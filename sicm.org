# -*- org-download-image-dir: "images"; -*-
#+title: Structure and Interpretation of Classical Mechanics
#+subtitle: Computational Physics!
#+startup: indent
#+date: 2020-05-26

Welcome to my tour of Structure and Interpretation of Classical Mechanics. I'm
working on this book to develop my sense of the best way to do research in
public; this book is heavy on math, programming and visualization, and should
stress the normal tools.

I'm attempting to take notes in on org-mode file, and generate all my code from
there.

I don't think I have the heart, or the time, to really do high-class notes of
every single section; but I am going to do each of the exercises, and explore
some of the code-based concepts in each section.

* Preface
:PROPERTIES:
:UNNUMBERED: t
:END:

The preface is already intriguing. A tour through the new notation, plus some
discussion of why a programming language is the best route in to this stuff.
Both of these are extremely powerful ideas, and why I was pulled to this book in
the first place.

The functional notation is:

\begin{equation}
  D (\partial_2 L \circ \Gamma[q]) - (\partial_1 L \circ \Gamma[q]) = 0
\end{equation}

Compare that to the traditional notation:

\begin{equation}
  \frac{d}{dt} \frac{\partial L}{\partial \dot q^i} -\frac{\partial L}{\partial q^i}= 0
\end{equation}

They have a nice riff on how this is totally ambiguous. $\Gamma$ is not a great
way to go.

* Lagrangian Mechanics
  :PROPERTIES:
  :header-args: :eval no-export :padline no
  :END:

** Exercise 1.1: Degrees of Freedom and 1.2: Generalized Coordinates

#+begin_quote
For each of the mechanical systems described below, give the number of degrees
of freedom of the configuration space. ([[https://tgvaughan.github.io/sicm/chapter001.html#Exe_1-1][SICM, ex1]])
#+end_quote

[[https://tgvaughan.github.io/sicm/chapter001.html#Exe_1-2][Exercise 1.2]] asks about the generalized coordinates of each, so I'll note those
here too.

1. Three juggling pins.

   **18 degrees of freedom** for three juggling pins - 3 position, 3 angles for
   each. OR **15** total, if you assume that the pin is symmetric; then you just
   need two degrees of tilt.

2. A spherical pendulum consisting of a point mass (the pendulum bob) hanging
   from a rigid massless rod attached to a fixed support point. The pendulum bob
   may move in any direction subject to the constraint imposed by the rigid rod.
   The point mass is subject to the uniform force of gravity.

   Spherical pendulum,hanging from a fixed support has **two degrees of
   freedom**, one for each angle.

3. Spherical DOUBLE pendulum has **four degrees of freedom**; two angles from
   previous, plus two more angles for the second pendulum off of the first.

   A spherical double pendulum, consisting of one point mass hanging from a
   rigid massless rod attached to a second point mass hanging from a second
   massless rod attached to a fixed support point. The point masses are subject
   to the uniform force of gravity.

4. A point mass sliding without friction on a rigid curved wire.

   **1 degree of freedom**, distance along the wire.

5. A top consisting of a rigid axisymmetric body with one point on the symmetry
   axis of the body attached to a fixed support, subject to a uniform
   gravitational force.

   Axisymmetric top has **TWO degrees of freedom**, for the angles off of
   vertical. But then we can't talk about its speed, so that's a little strange.
   I guess it has an angular momentum as a property, but that's not a
   coordinate.

6. The same as e, but not axisymmetric.

   We now have **THREE degrees of freedom**, one more for the angle of the top's
   rotation.

** Exercise 1.3: Fermat optics
:PROPERTIES:
:header-args+: :tangle ch1/ex1-3.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

This problem has us exploring some consequences for optics of the principle of
least time. [[https://tgvaughan.github.io/sicm/chapter001.html#Exe_1-3][Exercise 1.3]] states:

#+begin_quote
Fermat observed that the laws of reflection and refraction could be accounted
for by the following facts: Light travels in a straight line in any particular
medium with a velocity that depends upon the medium. The path taken by a ray
from a source to a destination through any sequence of media is a path of least
total time, compared to neighboring paths. Show that these facts imply the laws
of reflection and refraction.
#+end_quote

*** Law of Reflection

The [[https://en.wikipedia.org/wiki/Reflection_(physics)#Laws_of_reflection][law of reflection]] is described in the footnote:

#+begin_quote
For reflection the angle of incidence is equal to the angle of reflection.
#+end_quote

Here's the setup. The horizontal line is a mirror. The law states that $\theta_1
= \theta_2$.

#+DOWNLOADED: screenshot @ 2020-06-10 10:31:24
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_10-31-24_screenshot.png]]

We have to show that if we consider all possible paths from a given starting
point to a given endpoint, the path of minimum time will give us the law of
reflection.

The /actual/ path of minimum time is the straight line that avoids the mirror,
of course. If we force the light to bounce off of the mirror, then we have to
figure out where it will hit, where $x_p$ is, to minimize the time between the
start and end points.

There are two ways to solve this problem. We can use geometry and visual
intuition, or we can use calculus.

**** Geometry

First, recall this fact from the problem text:

#+begin_quote
Light travels in a straight line in any particular medium with a velocity that
depends upon the medium.
#+end_quote

There's no medium change, so if there were no mirror in its path, the light beam
would continue in a straight line. Instead of figuring out what the beam will do
when it hits the mirror, reflect the endpoint across the mirror and draw a
straight line between the start and "end" points:

#+DOWNLOADED: screenshot @ 2020-06-10 10:36:53
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_10-36-53_screenshot.png]]

The angle that the beam makes with the plane of the mirror is the same on both
sides of the mirror.

Now reflect the the "end" point and the segment of the beam that's crossed the
mirror back up. By symmetry, $\theta_1 = \theta_2$, and we've proved the law of
reflection.

**** Calculus

We can also solve this with calculus. Because the beam doesn't change media, its
speed $v$ stays constant, so minimizing the total distance $d$ is equivalent to
minimizing the time $t = {d \over v}$.

Set $x_1 = 0$ for convenience, and write the total distance the light travels as
a function of $x_p$:

\begin{equation}
d(x_p) = \sqrt{y_1^2 + x_p^2} + \sqrt{(x_2 - x_p)^2 + y_2^2}
\end{equation}

For practice, we can also define this function in Scheme.

#+begin_src scheme
(define ((total-distance x1 y1 x2 y2) xp)
  (+ (sqrt (+ (square (+ x1 xp))
              (square y1)))
     (sqrt (+ (square (- x2 (+ x1 xp)))
              (square y2)))))
#+end_src

#+RESULTS:
: #| total-distance |#

Here's the function again, generated from code, with general $t_1$:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((total-distance 'x_1 'y_1 'x_2 'y_2) 'x_p))
#+end_src

#+RESULTS[084acf42d4fe771c97db9cf39e92c75383662d30]:
\begin{equation}
\sqrt{{{x}_{1}}^{2} + 2 {x}_{1} {x}_{p} + {{x}_{p}}^{2} + {{y}_{1}}^{2}} + \sqrt{{{x}_{1}}^{2} - 2 {x}_{1} {x}_{2} + 2 {x}_{1} {x}_{p} + {{x}_{2}}^{2} - 2 {x}_{2} {x}_{p} + {{x}_{p}}^{2} + {{y}_{2}}^{2}}
\end{equation}

To find the $x_p$ that minimizes the total distance,

- take the derivative with respect to $x_p$,
- set it equal to 0 and
- solve for $x_p$.

The derivative will look cleaner in code if we keep the components of the sum
separate and prevent Scheme from "simplifying". Redefine the function to return
a tuple:

#+begin_src scheme
(define ((total-distance* x1 y1 x2 y2) xp)
  (up (sqrt (+ (square (+ x1 xp))
               (square y1)))
      (sqrt (+ (square (- x2 (+ x1 xp)))
               (square y2)))))
#+end_src

#+RESULTS:
: #| total-distance* |#

Here are the sum components:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((total-distance* 0 'y_1 'x_2 'y_2) 'x_p))
#+end_src

#+RESULTS[8080e49ee342b7a2a69c9c84337c37bc473a3c58]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \sqrt{{{x}_{p}}^{2} + {{y}_{1}}^{2}}} \cr \cr \displaystyle{ \sqrt{{{x}_{2}}^{2} - 2 {x}_{2} {x}_{p} + {{x}_{p}}^{2} + {{y}_{2}}^{2}}}\end{pmatrix}
\end{equation}

Taking a derivative is easy with =scmutils=. Just wrap the function in =D=:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((distance-fn (total-distance* 0 'y_1 'x_2 'y_2))
       (derivative (D distance-fn)))
  (->tex-equation
   (derivative 'x_p)))
#+end_src

#+RESULTS[5bbf36ca4a362ee2f2d2423071a6f818c8c93cab]:
\begin{equation}
\begin{pmatrix} \displaystyle{ {{{x}_{p}}\over {\sqrt{{{x}_{p}}^{2} + {{y}_{1}}^{2}}}}} \cr \cr \displaystyle{ {{ - {x}_{2} + {x}_{p}}\over {\sqrt{{{x}_{2}}^{2} - 2 {x}_{2} {x}_{p} + {{x}_{p}}^{2} + {{y}_{2}}^{2}}}}}\end{pmatrix}
\end{equation}

The first component is the base of base $x_p$ of the left triangle over the
total length. This ratio is equal to $\cos \theta_1$:

#+DOWNLOADED: screenshot @ 2020-06-10 10:36:53
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_10-36-53_screenshot.png]]

The bottom component is $-\cos \theta_2$, or ${- (x_2 - x_p)}$ over the length
of the right segment. Add these terms together, set them equal to 0 and
rearrange:

\begin{equation}
\label{eq:reflect-laws}
\cos \theta_1 = \cos \theta_2 \implies \theta_1 = \theta_2
\end{equation}

This description in terms of the two incident angles isn't so obvious from the
Scheme code. Still, you can use Scheme to check this result.

If the two angles are equal, then the left and right triangles are similar, and
the ratio of each base to height is equal:

\begin{equation}
\label{eq:reflect-ratio}
{x_p \over y_1} = {{x_2 - x_p} \over y_2}
\end{equation}

Solve for $x_p$ and rearrange:

\begin{equation}
\label{eq:reflect-ratio2}
x_p = {{y_1 x_2} \over {y_1 + y_2}}
\end{equation}

Plug this in to the derivative of the original =total-distance= function, and we
find that the derivative equals 0, as expected:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((distance-fn (total-distance 0 'y_1 'x_2 'y_2))
       (derivative (D distance-fn)))
  (->tex-equation
   (derivative (/ (* 'y_1 'x_2) (+ 'y_1 'y_2)))))
#+end_src

#+RESULTS[535d1b50ac55ba86347a21920c8bbf87153148eb]:
\begin{equation}
0
\end{equation}

If a beam of light travels in a way that minimizes total distance (and therefore
time in a constant medium), then it will reflect off of a mirror with the same
angle at which it arrived. The law of reflection holds.

*** Law of Refraction

The law of refraction is also called [[https://en.wikipedia.org/wiki/Snell%27s_law][Snell's law]]. Here's the description from
the footnote:

#+begin_quote
Refraction is described by Snell's law: when light passes from one medium to
another, the ratio of the sines of the angles made to the normal to the
interface is the inverse of the ratio of the refractive indices of the media.
The refractive index is the ratio of the speed of light in the vacuum to the
speed of light in the medium.
#+end_quote

First we'll tackle this with calculus.

**** Calculus

The setup here is slightly different. We have a light beam traveling from one
medium to another and changing speeds at a boundary located $a$ to the right of
the starting point. The goal is to figure out the point where the light will hit
the boundary, if we assume that the light will take the path of least time.

#+DOWNLOADED: screenshot @ 2020-06-10 12:03:11
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_12-03-11_screenshot.png]]

The refractive index $n_i = {c \over v_i}$, the speed of light $c$ in a vacuum
over the speed in the material. Rearranging, $v_i = {c \over n_i}$.

Time is distance over speed, so the total time that the beam spends between the
start and end points as a function of $y_p$, the point of contact with the
boundary, is:

\begin{equation}
  \begin{aligned}
    t(y_p) & = {c \sqrt{a^2 + y_p^2}\over v_1} + {c \sqrt{(x_2 - x_p)^2 + y_2^2} \over v_2} \cr
    & = {n_1 \over c} \sqrt{a^2 + y_p^2} + {n_2 \over c} \sqrt{(x_2 - x_p)^2 + y_2^2}
  \end{aligned}
\end{equation}

Take the derivative:

\begin{equation}
  Dt(y_p) = {1 \over c} \left({n_1 y_p \over \sqrt{a^2 + y_p^2}} - {n_2 (x_2 - x_p) \over \sqrt{(x_2 - x_p)^2 + y_2^2}}\right)
\end{equation}

Set the derivative equal to 0 and split terms:

\begin{equation}
\label{eq:almost-snell}
  {n_1 y_p \over \sqrt{a^2 + y_p^2}} = {n_2 (x_2 - x_p) \over \sqrt{(x_2 - x_p)^2 + y_2^2}}
\end{equation}

Similar to the law of reflection's result, each term (up to its $n_i$ multiple)
is equal to the height of the left or right triangle over the length of the
beam's path on the left or right of the boundary.

Equation \eqref{eq:almost-snell} simplifies to:

\begin{equation}
  n_1 \sin \theta_1 = n_2 \sin \theta_2
\end{equation}

Rearranging yields Snell's law:

\begin{equation}
{n_1 \over n_2} = {\sin \theta_2 \over \sin \theta_1}
\end{equation}

**** Geometry

I won't recreate this here, but the [[https://www.feynmanlectures.caltech.edu/I_26.html][Feynman Lectures on Physics]], in [[https://www.feynmanlectures.caltech.edu/I_26.html][Lecture 26]],
has a fantastic discussion about, and derivation of, the law of refraction using
no calculus, just geometry. I highly recommend you check out that lecture.
Feynman lays out a number of examples of how the principle of least time is not
just a restatement of the optical rules we already knew.

You can use the idea to guess what shape of mirror you'd want to build to focus
many light rays on a single point (a parabola), or how you might force all light
rays coming out of a single point to meet up again at another point (build a
converging lens).

This whole area of optics and least time has obsessed scientists for hundreds of
years. Spend a few minutes [[https://www.feynmanlectures.caltech.edu/I_26.html][poking around]] and see what you find.
** Section 1.4: Computing Actions
:PROPERTIES:
:header-args+: :tangle ch1/sec1-4.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

This is the first demo of how any of this stuff works, starting on page 15.
Here's our first Lagrangian, super simple.

#+name: L-free-particle
#+begin_src scheme
(define ((L-free-particle mass) local)
  (let ((v (velocity local)))
    (* 1/2 mass (dot-product v v))))
#+end_src

#+RESULTS: L-free-particle
: #| L-free-particle |#

Suppose we let $q$ denote a coordinate path function that maps time to position
components:

#+begin_src scheme
(define q
  (up (literal-function 'x)
      (literal-function 'y)
      (literal-function 'z)))
#+end_src

#+RESULTS:
: #| q |#

$\Gamma$ is a function that takes a coordinate path and returns a function of
time that gives the local tuple.

The value $\Gamma$ returns is called the "local tuple":

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((Gamma q) 't))
#+end_src

#+RESULTS[1f4aaac455bf48bd20965b4268009969bd7fd58e]:
\begin{equation}
\begin{pmatrix} \displaystyle{ t} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ x\left( t \right)} \cr \cr \displaystyle{ y\left( t \right)} \cr \cr \displaystyle{ z\left( t \right)}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ Dx\left( t \right)} \cr \cr \displaystyle{ Dy\left( t \right)} \cr \cr \displaystyle{ Dz\left( t \right)}\end{pmatrix}}\end{pmatrix}
\end{equation}

This is just $(t, q(t), (Dq)(t), ....)$ Where $D$ is the derivative. (Preview:
can a component of the coordinate path depend on the others? YES, and that would
impose constraints beyond the degrees of freedom you'd guess by just counting
the coordinates.)

Composing the Langrangian with $\Gamma$ gives you a function that computes the
Lagrangian at some instant:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((compose (L-free-particle 'm) (Gamma q)) 't))
#+end_src

#+RESULTS[49b01dd30b3d679e70016f72a5e51c78ecbf6c38]:
\begin{equation}
{{1}\over {2}} m {\left( Dz\left( t \right) \right)}^{2} + {{1}\over {2}} m {\left( Dy\left( t \right) \right)}^{2} + {{1}\over {2}} m {\left( Dx\left( t \right) \right)}^{2}
\end{equation}

This particular formula is written in terms of $x, y, z$ coordinates, but that
only came from the definition of $q$. As we'll see later, you could write a
coordinate transformation from some other totally different style of coordinates
(called "generalized coordinates") and the Lagrangian would look different, but
return the same value.

This function calculates the action $S[q](t_1, t_2)$:

#+begin_src scheme
(define (Lagrangian-action L q t1 t2)
  (definite-integral (compose L (Gamma q)) t1 t2))
#+end_src

#+RESULTS:
: #| Lagrangian-action |#

Here's an example path that a particle might take, moving along a straight line
as a function of $t$.

#+name: test-path
#+begin_src scheme
(define (test-path t)
  (up (+ (* 4 t) 7)
      (+ (* 3 t) 5)
      (+ (* 2 t) 1)))
#+end_src

#+RESULTS:
: #| test-path |#

Calculate the action for a particle of mass 3, between $t_1 = 0$ and $t_2 = 10$:

#+begin_src scheme :exports both :cache yes
(Lagrangian-action (L-free-particle 3) test-path 0.0 10.0)
#+end_src

#+RESULTS[78be3ee817bba9527071b0d765c261f632735187]:
: #| 435. |#

This happens to be the minimal action, since the path we provided was a uniform
path and the Lagrangian was for a free particle. If we'd provided a different
path, we would still get an action. Just not a stationary action. Infinitesimal
wiggles would change the action.

** Exercise 1.4: Lagrangian actions

#+begin_quote
For a free particle an appropriate Lagrangian is
#+end_quote

\begin{equation}
\label{eq:14lagrangian}
L(t, x, v) = {1 \over 2}mv^2
\end{equation}

#+begin_quote
Suppose that x is the constant-velocity straight-line path of a free particle,
such that $x_a = x(t_a)$ and $x_b = x(t_b)$. Show that the action on the
solution path is
#+end_quote

\begin{equation}
\label{eq:14result}
{m \over 2}{{(x_b - x_a)^2} \over {t_b - t_a}}
\end{equation}

The velocity is constant between the two points, so it must be equal to the
difference in position over the difference in time:

\begin{equation}
\label{eq:constant-v}
v = {{x(t_b) - x(t_a)} \over {t_b - t_a}} = {{x_b - x_a} \over {t_b - t_a}}
\end{equation}

The action is equal to:

\begin{equation}
  \label{eq:2}
  \begin{aligned}
    S[q](t_a, t_b) & = \int_{t_a}^{t_b} L(t, x, v) dx \cr
    & = \int_{t_a}^{t_b} {1 \over 2}mv(t)^2 dx \cr
    & = {m \over 2}{v(t)^2 t} \Bigr|_{t_a}^{t_b} \cr
    & = {m \over 2}{v(t_b)^2 t_b - v(t_a)^2 t_a}
  \end{aligned}
\end{equation}

The velocity is constant, so substitute in equation \eqref{eq:constant-v} and
simplify:

\begin{equation}
  \label{eq:4}
  \begin{aligned}
    S[q](t_a, t_b) & = {m \over 2}{({{x_b - x_a} \over {t_b - t_a}})^2 (t_b - t_a)} \cr
    & = {m \over 2}{(x_b - x_a)^2 \over {t_b - t_a}}
  \end{aligned}
\end{equation}

As expected.

** Paths of Minimum Action
:PROPERTIES:
:header-args+: :tangle ch1/min-action-paths.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

This section in the textbook implements path variation, so we can see the action
change (and increase!) off of the optimal path.

=make-eta= returns a function that equals 0 at $t_1$ and $t_2$:

#+begin_src scheme
(define ((make-eta nu t1 t2) t)
  (* (- t t1) (- t t2) (nu t)))
#+end_src

#+RESULTS:
: #| make-eta |#

Next, define a function that calculates the Lagrangian for a free particle, like
before, but adds in the path variation multiplied by some small scaling factor
$\epsilon$.

#+begin_src scheme
(define ((varied-free-particle-action mass q nu t1 t2) epsilon)
  (let ((eta (make-eta nu t1 t2)))
    (Lagrangian-action (L-free-particle mass)
                       (+ q (* epsilon eta))
                       t1
                       t2)))
#+end_src

#+RESULTS:
: #| varied-free-particle-action |#

The action for a small variation of $v(t) = (\sin(t), \cos(t), t^2)$ is larger
(top entry) vs the non-varied path (bottom entry), as expected.

#+begin_src scheme :results value raw :exports both :cache yes :noweb yes
<<test-path>>

(let ((action-fn (varied-free-particle-action 3.0 test-path
                                              (up sin cos square)
                                              0.0 10.0)))
  (->tex-equation
   (up (action-fn 0.001)
       (action-fn 0))))
#+end_src

#+RESULTS[3b26d789e2b0e25f6eb715c26a42c1ba4afe9017]:
\begin{equation}
\begin{pmatrix} \displaystyle{ 436.2912142857153} \cr \cr \displaystyle{ 435.}\end{pmatrix}
\end{equation}

What value of $\epsilon$ minimizes the action for the test path?

 Search over -2.0 to 1.0:

#+begin_src scheme :results value raw :exports both :cache yes
(let ((action-fn (varied-free-particle-action
                  3.0 test-path
                  (up sin cos square)
                  0.0 10.0)))
  (->tex-equation
   (minimize action-fn -2.0 1.0)))
#+end_src

#+RESULTS[0d64b0428a3899b4f3648f309e2ff669c54d5b42]:
\begin{equation}
5.134781488891349e-15\left( 435., 5 \right)
\end{equation}

The result shows that the minimum action occurs at $\epsilon = 0$, up to
numerical precision.

*** Finding trajectories that minimize the action

Is it possible to use this principle to actually /find/ a path, instead of
simply checking it?

First we need a function that builds a path. This version generates a path of
individual points, bracketed by the supplied start and end points $(t_0, q_0)$
and $(t_1, q_1)$. $qs$ is a list of intermediate points.

#+begin_src scheme
(define (make-path t0 q0 t1 q1 qs)
  (let ((n (length qs)))
    (let ((ts (linear-interpolants t0 t1 n)))
      (Lagrange-interpolation-function
       (append (list q0) qs (list q1))
       (append (list t0) ts (list t1))))))
#+end_src

#+RESULTS:
: #| make-path |#

This function sort-of-composes =make-path= and =Lagrangian-action=:

#+begin_src scheme
(define ((parametric-path-action L t0 q0 t1 q1) qs)
  (let ((path (make-path t0 q0 t1 q1 qs)))
    (Lagrangian-action L path t0 t1)))
#+end_src

#+RESULTS:
: #| parametric-path-action |#

Finally, a function that generates a path that minimizes the action:

#+begin_src scheme
(define (find-path L t0 q0 t1 q1 n)
  (let ((initial-qs (linear-interpolants q0 q1 n)))
    (let ((minimizing-qs
           (multidimensional-minimize
            (parametric-path-action L t0 q0 t1 q1)
            initial-qs)))
      (make-path t0 q0 t1 q1 minimizing-qs))))
#+end_src

#+RESULTS:
: #| find-path |#

Let's test it out with a Lagrangian for a one dimensional harmonic oscillator
with spring constant $k$:

#+name: L-harmonic
#+begin_src scheme
(define ((L-harmonic m k) local)
  (let ((q (coordinate local))
        (v (velocity local)))
    (- (* 1/2 m (square v)) (* 1/2 k (square q)))))
#+end_src

#+RESULTS:
: #| L-harmonic |#

#+begin_src scheme
(define win2 (frame 0.0 :pi/2 0 1))

(define harmonic-path
  (find-path (L-harmonic 1.0 1.0) 0.0 1.0 :pi/2 0.0 3))

(plot-function win2 harmonic-path 0 :pi (/ :pi 100))
#+end_src

#+RESULTS:
: #| win2 |#
:
: #| harmonic-path |#

The path looks like a harmonic oscillator that starts high and bounces down,
after $\pi \over 2$ seconds, down to 0.

#+DOWNLOADED: screenshot @ 2020-06-10 14:24:14
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_14-24-14_screenshot.png]]


** Exercise 1.5: Solution process
:PROPERTIES:
:header-args+: :tangle ch1/ex1-5.scm :comments org
:END:

The goal of this exercise is really just to watch the minimization process that
they've given us.

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

#+begin_quote
We can watch the progress of the minimization by modifying the procedure
parametric-path-action to plot the path each time the action is computed.
#+end_quote

The functions they've provided define a window, and then a version of
=parametric-path-action= that updates the graph as it minimizes:

#+begin_src scheme :noweb yes
(define win2 (frame 0.0 :pi/2 0.0 1.2))

<<L-harmonic>>

(define ((parametric-path-action Lagrangian t0 q0 t1 q1)
         intermediate-qs)
  (let ((path (make-path t0 q0 t1 q1 intermediate-qs)))
    ;; display path
    (graphics-clear win2)
    (plot-function win2 path t0 t1 (/ (- t1 t0) 100))
    ;; compute action
    (Lagrangian-action Lagrangian path t0 t1)))
#+end_src

#+RESULTS:
: #| win2 |#
:
: #| L-harmonic |#
:
: #| parametric-path-action |#

This final command runs the minimization and updates the graph as it goes.

#+begin_src scheme
(find-path (L-harmonic 1.0 1.0) 0.0 1.0 :pi/2 0.0 2)
#+end_src

#+RESULTS:
: #| poly |#

The minimization looks like this:

#+DOWNLOADED: https://i.imgur.com/AJBpDgU.gif @ 2020-05-29 10:12:19
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
[[file:images/Lagrangian_Mechanics/2020-05-29_10-12-19_AJBpDgU.gif]]

** Exercise 1.6: Minimizing action
:PROPERTIES:
:header-args+: :tangle ch1/ex1-6.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

The problem asks:

#+begin_quote
Suppose we try to obtain a path by minimizing an action for an impossible
problem. For example, suppose we have a free particle and we impose endpoint
conditions on the velocities as well as the positions that are inconsistent with
the particle being free. Does the formalism protect itself from such an
unpleasant attack? You may find it illuminating to program it and see what
happens.
#+end_quote

I spent a good amount of time thinking about this one. When I attacked this book
five years ago I found it very confusing. It makes more sense now that I've
moved farther in the book and understand what it's asking us to do.

Let's say you take, as the authors suggest, some path, and impose velocity
constraints on the endpoints in addition to the position constraints.

Usually, you constrain the coordinates at each endpoint and force a path that
minimizes the action between two times. So what does it mean to impose velocity
conditions?

The key is to realize that on the computer, you're forcing a path to be composed
of a bunch of discrete points. If you can force a point into the path that is
NOT controlled by the optimizer, then you can force a velocity at some point in
the path that makes no sense for minimal action.

Let's define a new version of =parametric-path-action= that also takes an offset
for the initial and final points. We'll force the first and last intermediate
point to be equal to the start and end points, plus the offsets.

Then, we can try to find an action-minimizing path, but force the optimizer to
deal with not just our endpoint conditions, but these two extra points as well.
Forcing two points on each end will force an initial velocity condition.

Here's the implementation:

#+begin_src scheme

(define (((parametric-path-action* win)
          Lagrangian t0 q0 offset0 t1 q1 offset1)
         intermediate-qs)
  (let ((intermediate-qs* (append (list (+ q0 offset0))
                                  intermediate-qs
                                  (list (+ q1 offset1)))))
    (let ((path (make-path t0 q0 t1 q1 intermediate-qs*)))
      ;; display path
      (graphics-clear win)
      (plot-function win path t0 t1 (/ (- t1 t0) 100))
      ;; compute action
      (Lagrangian-action Lagrangian path t0 t1))))
#+end_src

#+RESULTS:
: #| parametric-path-action* |#

You could try a similar trick by modifying the first and last entries of
=intermediate-qs= instead of appending a point, but I suspect that the optimizer
would be able to figure out how to offset your offset.

Next, a version of =find-path= that passes the offsets through to the new
=parametric-path-action*=:

#+begin_src scheme
(define ((find-path* win) L t0 q0 offset0 t1 q1 offset1 n)
  (let ((initial-qs (linear-interpolants q0 q1 n)))
    (let* ((action (parametric-path-action* win))
           (minimizing-qs
            (multidimensional-minimize
             (action L t0 q0 offset0 t1 q1 offset1)
             initial-qs)))
      (make-path t0 q0 t1 q1 minimizing-qs))))
#+end_src

#+RESULTS:
: #| find-path* |#

And finally, a function that can execute runs of our formalism-killing
experiment.

#+begin_src scheme
(define (one-six offset0 offset1 n)
  (let* ((tmax 10)
         (win (frame -1 (+ tmax 1) -0.2 (+ 1.2 offset0 offset1)))
         (find (find-path* win))
         (L (L-free-particle 3.0))
         (path (find L
                     0. 1. offset0
                     tmax 0. offset1
                     n)))
    (Lagrangian-action L path 0 tmax)))
#+end_src

#+RESULTS:
: #| one-six |#

=one-six= takes two offsets and runs the minimization routine against
=L-free-particle=, moving from position 1 to 0 over 10 seconds. =n= controls the
number of interpolation points that the system will use.

Internally, remember, =parametric-path-action*= will append two extra fixed
offset points to the =n= intermediate points that the optimizer gets to control.

*** Executions

Let's run the code with 0 offsets and 3 interpolation points. Note that this
should /still/ distort the path, since we now have two fixed points at the start
and end. This is effectively imposing a 0 velocity constraint at the beginning
and end.

Here's the code, and its output:

#+begin_src scheme
(one-six 0 0 3)
#+end_src

#+DOWNLOADED: file:///Users/samritchie/Desktop/ex1_6_nooffset.gif @ 2020-06-10 15:10:46
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_15-10-46_ex1_6_nooffset.gif]]


The path ends up looking almost sinusoidal, and takes a while to converge. This
is the best polynomial that the system can come up with that matches the 7
points (3 interpolated, 2 offsets, 1 start and 1 end).

Here's a small positive velocity imposed at the beginning:

#+begin_src scheme
(one-six 0.2 0 3)
#+end_src

#+DOWNLOADED: file:///Users/samritchie/Desktop/ex1_6_02offset.gif @ 2020-06-10 15:10:53
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_15-10-53_ex1_6_02offset.gif]]

The system takes longer to converge. Here's a larger impulse of 0.5:

#+begin_src scheme
(one-six 0.5 0 3)
#+end_src

#+DOWNLOADED: file:///Users/samritchie/Desktop/ex1_6_05offset.gif @ 2020-06-10 15:11:10
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_15-11-10_ex1_6_05offset.gif]]


And a moderate negative velocity, just for fun:

#+begin_src scheme
(one-six -0.5 0 3)
#+end_src

#+DOWNLOADED: file:///Users/samritchie/Desktop/ex1_6_neg5offset.gif @ 2020-06-10 15:11:27
#+attr_org: :width 400px
#+attr_html: :width 80% :align center
#+attr_latex: :width 8cm
[[file:images/Lagrangian_Mechanics/2020-06-10_15-11-27_ex1_6_neg5offset.gif]]


The process __does__ converge, but this is only because we only used 3
intermediate points. If you bump up to 10 points, with this code:

#+begin_src scheme
(one-six 20 0 3)
#+end_src

#+RESULTS:

The optimization freezes.

What is going on here? Why does the minimizer converge?

With velocity constraints imposed, we're no longer minimizing the action with
respect to some Lagrangian. We're minimizing the action given two constraints.
You have the Lagrangian, and then the warring goal of the polynomial
interpolation forcing a certain shape on the path. At some point, the minimizer
breaks; internally it ends up pinned between two tugging constraints.

If you make the impulse too big or force too many intermediate points, then the
war is too hardcore and the process never converges. But it's important to note
here the details of the optimizer. This detail doesn't break reality.

If you /do/ need to impose velocity conditions, it turns out you can use a
Lagrangian that takes acceleration into account. This is discussed in Exercise
1.10.

** Exercise 1.7: Properties of $\delta$

This exercise asks us to prove various products of the variation operator
$\delta_\eta$. This is a sort of higher-order derivative operator. Apply it to a
higher order function $f$, and you'll get a function back that returns the
/sensitivity/ of $f$ to fluctuations in its input path function. (Confusing?
Check out [[https://tgvaughan.github.io/sicm/chapter001.html#h1-6a][the textbook]].

*** Variation Product Rule

The product rule for variations states that:

\begin{equation}
\label{eq:var-prod}
\delta_\eta (f g)[q] = \delta_\eta f[q] g[q] + f[q] \delta_\eta g[q]
\end{equation}

Write out the left side explicitly, using the definition of $\delta_\eta$:

\begin{equation}
\label{eq:var-prod-proof}
  \delta_\eta (f g)[q] = \lim_{\epsilon \to 0} \left( {f[q + \epsilon\eta]g[q + \epsilon\eta] - f[q]g[q]} \over \epsilon \right)
\end{equation}

Make the inspired move to add and subtract $f[q] g[q + \epsilon \eta]$ inside
the limit, rearrange and factor out the terms that have appeared in common.
(Stare at this for a moment to make sure the steps are clear.)

\begin{equation}
\label{eq:var-prod-proof2}
\delta_\eta (f g)[q] = \lim_{\epsilon \to 0} \left( {g[q + \epsilon\eta](f[q + \epsilon\eta] - f[q])} \over \epsilon \right) + f[q] \lim_{\epsilon \to 0} \left( {(g[q + \epsilon \eta] - g[q])} \over \epsilon \right)
\end{equation}

You might recognize that we've now isolated terms that look like $\delta_\eta
f[q]$ and $\delta_\eta g[q]$, as $\epsilon$ approaches 0. Notice that as this
happens, $g[q + \epsilon\eta] \to g[q]$, and the whole expression evaluates to
the product rule we were seeking:

\begin{equation}
\label{eq:var-prod2}
\delta_\eta (f g)[q] = \delta_\eta f[q]\,g[q] + f[q]\,\delta_\eta g[q]
\end{equation}

*** Variation Sum Rule

The sum rule is easier. Our goal is:

\begin{equation}
\label{eq:var-sum}
\delta_\eta (f + g)[q] = \delta_\eta f[q] + \delta_\eta g[q]
\end{equation}

Expand out the definition of the variation operator, regroup terms, allow
$\epsilon \to 0$ and notice that we've recovered our goal.

\begin{equation}
\label{eq:var-sum-proof}
\begin{aligned}
  \delta_\eta (f + g)[q] & = \lim_{\epsilon \to 0} \left( {(f[q + \epsilon\eta] + g[q + \epsilon\eta]) - (f[q] + g[q])} \over \epsilon \right) \cr
  & = \lim_{\epsilon \to 0} \left( {f[q + \epsilon\eta] - f[q]} \over \epsilon \right) + \lim_{\epsilon \to 0} \left( {g[q + \epsilon\eta] - g[q]} \over \epsilon \right) \cr
  & = \delta_\eta f[q] + \delta_\eta g[q]
\end{aligned}
\end{equation}

Done!

*** Variation Scalar Multiplication

We want to show that $\delta_\eta$ preserves multiplication by a scalar $c$:

\begin{equation}
\label{eq:var-scalar}
\delta_\eta (c g)[q] = c \delta_\eta g[q]
\end{equation}

Expand out the definition of the variation operator:

\begin{equation}
\label{eq:var-scalar-proof}
\begin{aligned}
  \delta_\eta (c g)[q] & = \lim_{\epsilon \to 0} \left( {c f[q + \epsilon\eta] - c f[q]} \over \epsilon \right) \cr
  & = c \lim_{\epsilon \to 0} \left( {f[q + \epsilon\eta] - f[q]} \over \epsilon \right) \cr
  & = c \delta_\eta f[q]
\end{aligned}
\end{equation}

Done, since the limit operator preserves scalar multiplication.

*** Chain Rule for Variations

The chain rule for variations states that:

\begin{equation}
\label{eq:var-chain}
\delta_\eta h[q] = (DF \circ g[q])\, \delta_\eta g[q] \textrm{ with } h[q] = F \circ g[q]
\end{equation}

Expand this out using the definition of $\delta_\eta$:

\begin{equation}
\label{eq:var-chain-proof}
  \delta_\eta (F \circ g[q]) = \lim_{\epsilon \to 0} \left( {(F \circ g[q + \epsilon\eta]) - (F \circ g[q])} \over \epsilon \right)
\end{equation}

Now multiply the term inside the limit by $1 = {{g[q + \epsilon\eta] - g[q]}
\over {g[q + \epsilon\eta] - g[q]}}$ and factor out the new, more recognizable
product that forms:

\begin{equation}
\label{eq:var-chain-proof2}
\begin{aligned}
  \delta_\eta (F \circ g[q]) & = \lim_{\epsilon \to 0} \left( {((F \circ g[q + \epsilon\eta]) - (F \circ g[q]))({g[q + \epsilon\eta] - g[q]})} \over {({g[q + \epsilon\eta] - g[q]}) \epsilon} \right) \cr
  & = \lim_{\epsilon \to 0} \left( {(F \circ g[q + \epsilon\eta]) - (F \circ g[q])} \over {g[q + \epsilon\eta] - g[q]} \right) \delta_\eta g[q]
\end{aligned}
\end{equation}

The remaining term inside the limit has the form of a derivative of some
function $f$ evaluated at a point $a$.

\begin{equation}
\label{eq:var-chain-proof3}
Df(a) = \lim_{b \to a} \left( {f(b) - f(a)} \over {b - a} \right)
\end{equation}

Where $b = g[q + \epsilon \eta]$ and $a = g[q]$. As $\epsilon \to 0$,
$F \circ g[q + \epsilon \eta] \to F \circ g[q]$. We know this because we showed
that $\delta_\eta g[q]$ exists and factored it out.

Remember that that this is all function algebra, so composition here is
analogous to function application; so $F$ is indeed the $f$ in equation
\eqref{eq:var-chain-proof3}, and the remaining term collapses to $DF$ evaluated
at $a = g[q]$:

\begin{equation}
\label{eq:var-chain-proof4}
  \delta_\eta (F \circ g[q]) = (DF \circ g[q])\, \delta_\eta g[q]
\end{equation}

*** $\delta_\eta$ commutes with $D$

We need to show the derivative can commute with a normal derivative of the
function that $f$ returns after it's passed a path:

\begin{equation}
\label{eq:var-commute}
D \delta_\eta f[q] = \delta_\eta g[q] \textrm{ with } g[q] = D(f[q])
\end{equation}

Expand the left side by the definition of $\delta_\eta$:

\begin{equation}
\label{eq:var-commute-proof}
  D (\delta_\eta f[q]) = D \lim_{\epsilon \to 0} \left( {(f[q + \epsilon\eta]) - (f[q])} \over \epsilon \right)
\end{equation}

The derivative $D$ is a linear operator, so we can move it in to the limit and
distribute it over subtraction:

\begin{equation}
\label{eq:var-commute-proof2}
\begin{aligned}
  D (\delta_\eta f[q]) & = \lim_{\epsilon \to 0} \left( {D(f[q + \epsilon\eta]) - D(f[q])} \over \epsilon \right) \cr
  & = \delta_\eta(D(f[q]))
\end{aligned}
\end{equation}

Our goal is achieved.

** Exercise 1.8: Implementation of $\delta$
:PROPERTIES:
:header-args+: :tangle ch1/ex1-8.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

*** Part A: Implement $\delta_\eta$

The goal here is to implement $\delta_\eta$ as a procedure. Explicitly:

#+begin_quote
Suppose we have a procedure =f= that implements a path-dependent function: for
path =q= and time =t= it has the value =((f q) t)=. The procedure delta computes
the variation $\delta_\eta f[q](t)$ as the value of the expression =((((delta
eta) f) q) t)=. Complete the definition of =delta=:
#+end_quote

After laboriously proving all of the properties above, the actual implementation
feels so simple.

The key is equation 1.22 in the book:

\begin{equation}
\label{eq:1-22}
\delta_\eta f[q] = \lim_{\epsilon \to 0} \left( {g(\epsilon) - g(0)} \over \epsilon \right) = Dg(0)
\end{equation}

Given $g(\epsilon) = f[q + \epsilon \eta]$. Through the magic of automatic
differentiation we can simply write:

#+begin_src scheme
(define (((delta eta) f) q)
  (let ((g (lambda (eps)
             (f (+ q (* eps eta))))))
    ((D g) 0)))
#+end_src

#+RESULTS:
: #| delta |#

It's almost spooky, that $D$ can somehow figure out what to do here.

*** Part B: Check $\delta_\eta$'s properties

Part B's problem description gave us a path-dependent function similar to this
one:

#+begin_src scheme
(define ((fn sym) q)
  (let* ((Local (UP Real (UP* Real) (UP* Real)))
         (F (literal-function sym (-> Local Real))))
    (compose F (Gamma q))))
#+end_src

#+RESULTS:
: #| fn |#

I've modified it slightly to take in a symbol, since we'll need to generate
multiple functions for a few of the rules.

$fn$ takes a symbol like $F$ and a path function - a function from $t$ to any
number of coordinates (see the =UP*=?) - and returns a generic expression for a
path dependent function $F$ that acts via $F \circ \Gamma[q]$. $F$ might be a
Lagrangian, for example.

The textbook also gives us this function from $t \to (x, y)$ to test out the
properties above. I've added an $\eta$ of the same type signature that we can
use to add variation to the path.

#+begin_src scheme
(define q (literal-function 'q (-> Real (UP Real Real))))
(define eta (literal-function 'q (-> Real (UP Real Real))))
#+end_src

#+RESULTS:
: #| q |#
:
: #| eta |#

**** Variation Product Rule

Equation \eqref{eq:var-prod} states the product rule for variations. Here it is
in code. I've implemented the right and left sides and subtracted them. As
expected, the result is 0:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((f (fn 'f))
       (g (fn 'g))
       (de (delta eta)))
  (let ((left ((de (* f g)) q))
        (right (+ (* (g q) ((de f) q))
                  (* (f q) ((de g) q)))))
    (->tex-equation
     ((- left right) 't))))
#+end_src

#+RESULTS[a1c8ed29c32a4b30412af5c2bbd632edd7a63a42]:
\begin{equation}
0
\end{equation}

**** Variation Sum Rule

The sum rule is similar. Here's the Scheme implementation of equation
\eqref{eq:var-sum}:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((f (fn 'f))
       (g (fn 'g))
       (de (delta eta)))
  (let ((left ((de (+ f g)) q))
        (right (+ ((de f) q)
                  ((de g) q))))
    (->tex-equation
     ((- left right) 't))))
#+end_src

#+RESULTS[2109df50bd5a522b7140b5656b20b90ee52e5e63]:
\begin{equation}
0
\end{equation}

**** Variation Scalar Multiplication

Here's equation \eqref{eq:var-scalar} in code. The sides are equal, so their
difference is 0:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((g (fn 'g))
       (de (delta eta)))
  (let ((left ((de (* 'c g)) q))
        (right (* 'c ((de g) q))))
    (->tex-equation
     ((- left right) 't))))
#+end_src

#+RESULTS[9feb0bdde1e870101cd1e1e41df0774ae2be5d6b]:
\begin{equation}
0
\end{equation}

**** Chain Rule for Variations

To compute the chain rule we'll need a version of =fn= that takes the derivative
of the inner function:

#+begin_src scheme
(define ((Dfn sym) q)
  (let* ((Local (UP Real (UP* Real) (UP* Real)))
         (F (literal-function sym (-> Local Real))))
    (compose (D F) (Gamma q))))
#+end_src

For the Scheme implementation, remember that both =fn= and =Dfn= have $\Gamma$
baked in. The $g$ in equation \eqref{eq:var-chain} is hardcoded to $\Gamma$ in
the function below.

Here's a check that the two sides of equation \eqref{eq:var-chain} are equal:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((h (fn 'F))
       (dh (Dfn 'F))
       (de (delta eta)))
  (let ((left (de h))
        (right (* dh (de Gamma))))
    (->tex-equation
     (((- left right) q) 't))))
#+end_src

#+RESULTS[539d27f8dd21a8838b24cf4b3c24a157597e0a42]:
\begin{equation}
0
\end{equation}

**** $\delta_\eta$ commutes with $D$

Our final test. Here's equation \eqref{eq:var-commute} in code, showing that the
derivative commutes with the variation operator:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((f (fn 'f))
       (g (compose D f))
       (de (delta eta)))
  (let ((left (D ((de f) q)))
        (right ((de g) q)))
    (->tex-equation
     ((- left right) 't))))
#+end_src

#+RESULTS[5faf1227403cf244932447535a4366a066995299]:
\begin{equation}
0
\end{equation}

** Exercise 1.9: Lagrange's equations

This exercise has us deriving Lagrange's equations in steps for three different
systems.

You should do this on paper, then go look at Exercise 1.12 for the Scheme code
that implements each Lagrangian and shows the steps required to get to
Lagrange's equations.

** Exercise 1.10: Higher-derivative Lagrangians
:PROPERTIES:
:header-args+: :tangle ch1/ex1-10.scm :comments org
:END:

** Exercise 1.11: Kepler's third law
:PROPERTIES:
:header-args+: :tangle ch1/ex1-11.scm :comments org
:END:

** Exercise 1.12: Lagrange's equations (code)
:PROPERTIES:
:header-args+: :tangle ch1/ex1-12.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

This exercise has us writing code for the three systems described in [[https://tgvaughan.github.io/sicm/chapter001.html#Exe_1-9][Exercise
1.9]]. Before we start, here's a function that will display an up-tuple of:

- $\partial_1 L \circ \Gamma[q]$, the generalized force
- $\partial_2 L \circ \Gamma[q]$, the generalized momenta
- $D(\partial_2 L \circ \Gamma[q])$, the derivative of our momenta
- The Lagrange equations for the system.

#+begin_src scheme
(define (lagrange-equation-steps L q)
  (let* ((p1 (compose ((partial 1) L) (Gamma q)))
         (p2 (compose ((partial 2) L) (Gamma q)))
         (dp2 (D p2)))
    (->tex-equation
     ((up p1 p2 dp2 (- dp2 p1))
      't))))
#+end_src

#+RESULTS:
: #| lagrange-equation-steps |#

We'll call this for each system to show the steps required to derive Lagrange's
equations.

*** Part A: Ideal Planar Pendulum

From the book:

#+begin_quote
An ideal planar pendulum consists of a bob of mass $m$ connected to a pivot by a
massless rod of length $l$ subject to uniform gravitational acceleration $g$. A
Lagrangian is $L(t, \theta, \dot{\theta}) = {1 \over 2} ml^2\dot{\theta}^2 +
mgl\cos \theta$. The formal parameters of $L$ are $t$, $\theta$, and
$\dot{\theta}$; $\theta$ measures the angle of the pendulum rod to a plumb line
and $\dot{\theta}$ is the angular velocity of the rod.
#+end_quote

Here is the Lagrangian described above:

#+begin_src scheme
(define ((L-pendulum m g l) local)
  (let ((theta (coordinate local))
        (theta_dot (velocity local)))
    (- (* 1/2 m (square l) (square theta_dot))
       (* m g l (cos theta)))))
#+end_src

#+RESULTS:
: #| L-pendulum |#

And the steps that lead us to Lagrange's equations:

#+begin_src scheme :results value raw :exports both :cache yes
(lagrange-equation-steps
 (L-pendulum 'm 'g 'l)
 (literal-function 'theta))
#+end_src

#+RESULTS[aaf5812bee20b3464cf996ad648f7000e663545b]:
\begin{equation}
\begin{pmatrix} \displaystyle{ g l m \sin\left( \theta\left( t \right) \right)} \cr \cr \displaystyle{ {l}^{2} m D\theta\left( t \right)} \cr \cr \displaystyle{ {l}^{2} m {D}^{2}\theta\left( t \right)} \cr \cr \displaystyle{  - g l m \sin\left( \theta\left( t \right) \right) + {l}^{2} m {D}^{2}\theta\left( t \right)}\end{pmatrix}
\end{equation}

The final Lagrange equation needs some hand simplification. Divide out $g$ and
$l$, and include a factor of $-1$ to make things look nice:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((L (L-pendulum 'm 'g 'l))
       (theta (literal-function 'theta))
       (eq ((Lagrange-equations L) theta)))
  (->tex-equation
   ((/ eq (* -1 'm 'l))
    't)))
#+end_src

#+RESULTS[9fbaa84c941e3a2a433e2d13a043dc3f291303a5]:
\begin{equation}
g \sin\left( \theta\left( t \right) \right) - l {D}^{2}\theta\left( t \right)
\end{equation}

Much better.

*** Part B: 2D Potential

From the book:

#+begin_quote
A particle of mass $m$ moves in a two-dimensional potential $V(x, y) = {(x^2 +
y^2) \over 2} + x^2 y - {y^3 \over 3}$, where $x$ and $y$ are rectangular
coordinates of the particle. A Lagrangian is $L(t;x, y; v_x, v_y) = {1 \over 2}
m (v_x^2 + v_y^2) - V(x, y)$.
#+end_quote

Define the potential $V$ and the Lagrangian separately. The Lagrangian here is
actually written in a form general enough that it would work for any number of
dimensions in rectangular space, given some potential $V$. This is something to
note for later, when we discuss coordinate transformations.

#+begin_src scheme
(define (V q)
  (let ((x (ref q 0))
        (y (ref q 1)))
    (- (+ (/ (+ (square x)
                (square y))
             2)
          (* (square x) y))
       (/ (cube y) 3))))

(define (((L-2d-potential m) V) local)
  (- (* 1/2 m (square (velocity local)))
     (V (coordinate local))))
#+end_src

#+RESULTS:
: #| V |#
:
: #| L-2d-potential |#

Next, the derivation of the Lagrange equations:

#+begin_src scheme :results value raw :exports both :cache yes
(lagrange-equation-steps
 ((L-2d-potential 'm) V)
 (up (literal-function 'x)
     (literal-function 'y)))
#+end_src

#+RESULTS[934ef9c2a8a96a3dd4ad506e022deb8a6886de5c]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{  - 2 y\left( t \right) x\left( t \right) - x\left( t \right)} \cr \cr \displaystyle{ {\left( y\left( t \right) \right)}^{2} - {\left( x\left( t \right) \right)}^{2} - y\left( t \right)}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ m Dx\left( t \right)} \cr \cr \displaystyle{ m Dy\left( t \right)}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ m {D}^{2}x\left( t \right)} \cr \cr \displaystyle{ m {D}^{2}y\left( t \right)}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ m {D}^{2}x\left( t \right) + 2 y\left( t \right) x\left( t \right) + x\left( t \right)} \cr \cr \displaystyle{ m {D}^{2}y\left( t \right) - {\left( y\left( t \right) \right)}^{2} + {\left( x\left( t \right) \right)}^{2} + y\left( t \right)}\end{bmatrix}}\end{pmatrix}
\end{equation}

The final down-tuple gives us the Lagrange equations for $x$ and $y$
respectively.

*** Part C: Particle on a Sphere

From the book:

#+begin_quote
A Lagrangian for a particle of mass $m$ constrained to move on a sphere of
radius $R$ is $L(t; \theta, \phi; \alpha, \beta) = {1 \over 2} m
R^2(\alpha^2+(\beta\sin\theta)^2)$. The angle $\theta$ is the colatitude of the
particle and $\phi$ is the longitude; the rate of change of the colatitude is
$\alpha$ and the rate of change of the longitude is $\beta$.
#+end_quote

Here is the Lagrangian:

#+begin_src scheme
(define ((L-sphere m R) local)
  (let* ((q (coordinate local))
         (qdot (velocity local))
         (theta (ref q 0))
         (alpha (ref qdot 0))
         (beta (ref qdot 1)))
    (* 1/2 m (square R)
       (+ (square alpha)
          (square (* beta (sin theta)))))))
#+end_src

#+RESULTS:
: #| L-sphere |#

The final Lagrange equations have a few terms that we can cancel out. Scheme
doesn't know that these are meant to be residuals, so it won't cancel out
factors that we can see by eye are missing. Here is the full derivation:

#+begin_src scheme :results value raw :exports both :cache yes
(lagrange-equation-steps
 (L-sphere 'm 'R)
 (up (literal-function 'theta)
     (literal-function 'phi)))
#+end_src

#+RESULTS[5d05668e1d73bcd0f884eb8ba013c4eb56e72fda]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ {R}^{2} m \sin\left( \theta\left( t \right) \right) \cos\left( \theta\left( t \right) \right) {\left( D\phi\left( t \right) \right)}^{2}} \cr \cr \displaystyle{ 0}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ {R}^{2} m D\theta\left( t \right)} \cr \cr \displaystyle{ {R}^{2} m {\left( \sin\left( \theta\left( t \right) \right) \right)}^{2} D\phi\left( t \right)}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ {R}^{2} m {D}^{2}\theta\left( t \right)} \cr \cr \displaystyle{ 2 {R}^{2} m \sin\left( \theta\left( t \right) \right) D\theta\left( t \right) \cos\left( \theta\left( t \right) \right) D\phi\left( t \right) + {R}^{2} m {\left( \sin\left( \theta\left( t \right) \right) \right)}^{2} {D}^{2}\phi\left( t \right)}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{  - {R}^{2} m \sin\left( \theta\left( t \right) \right) \cos\left( \theta\left( t \right) \right) {\left( D\phi\left( t \right) \right)}^{2} + {R}^{2} m {D}^{2}\theta\left( t \right)} \cr \cr \displaystyle{ 2 {R}^{2} m \sin\left( \theta\left( t \right) \right) D\theta\left( t \right) \cos\left( \theta\left( t \right) \right) D\phi\left( t \right) + {R}^{2} m {\left( \sin\left( \theta\left( t \right) \right) \right)}^{2} {D}^{2}\phi\left( t \right)}\end{bmatrix}}\end{pmatrix}
\end{equation}

Next, get the Lagrange equations in hand and manually simplify each equation by
dividing out, respectively, $mR^2$ and $mR^2 \sin \theta$:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((L (L-sphere 'm 'R))
       (theta (literal-function 'theta))
       (q (up theta (literal-function 'phi)))
       (le ((Lagrange-equations L) q)))
  (let ((eq1 (ref le 0))
        (eq2 (ref le 1)))
    (->tex-equation
     ((up (/ eq1 (* 'm (square 'R)))
          (/ eq2 (* (sin theta) 'm (square 'R))))
      't))))
#+end_src

#+RESULTS[db89e66528e605f07cf1f57c845568eb0c67777c]:
\begin{equation}
\begin{pmatrix} \displaystyle{  - \sin\left( \theta\left( t \right) \right) \cos\left( \theta\left( t \right) \right) {\left( D\phi\left( t \right) \right)}^{2} + {D}^{2}\theta\left( t \right)} \cr \cr \displaystyle{ 2 D\theta\left( t \right) \cos\left( \theta\left( t \right) \right) D\phi\left( t \right) + \sin\left( \theta\left( t \right) \right) {D}^{2}\phi\left( t \right)}\end{pmatrix}
\end{equation}

Looking good. These are the residuals for $\theta$ and $\phi$, respectively.

** Exercise 1.13: Higher-derivative Lagrangians (code)
:PROPERTIES:
:header-args+: :tangle ch1/ex1-13.scm :comments org
:END:

** Exercise 1.14: Coordinate-independence of Lagrange equations
:PROPERTIES:
:header-args+: :tangle ch1/ex1-14.scm :comments org
:END:

** Exercise 1.15: Equivalence
:PROPERTIES:
:header-args+: :tangle ch1/ex1-15.scm :comments org
:END:

NOTE - I have a strong suspicion here that we can show that what is actually
going on is that we end up with a total time derivative that we can ignore. The
final terms at the end that cancel... why is it that they work out the way they
do? It would be nice to try and use the time-derivative test machinery we built
to take a look there.

This one was a serious doozy. I think that this exercise can be a great way to
show off the computer algebra system, and show off the steps that I go through
to make a proof.

But I also want to pull back and stare at the formula. What is going on? What is
the meaning of the extra terms? If we can say, for example, that they're a total
time derivative, looking at the future, that would be great. There has to be a
reason that the Lagrangian doesn't change.

The same thing happens when you look at a new Lagrangian and see a "fictitious
force term" for, say, centrifugal force. There is something going on here.


Checking that composition distributes over multiplication...

#+begin_src scheme
(define f (literal-function 'f))
(define g (literal-function 'g))
(define h (literal-function 'h))
#+end_src

looks good! These are the same expression.

#+begin_src scheme
((compose (* f g) h) 't)
((* (compose f h) (compose g h)) 't)
#+end_src

 This is the general form of a path transformation; big surprise, this is very
 close to the code on page 46. I'm going to keep my version, since I don't want
 to get too confused, here.

#+begin_src scheme
(define ((F->C F) local)
  (let ((t (time local))
        (x (coordinate local))
        (v (velocity local)))
    (up t
        (F t x)
        (+ (((partial 0) F) t x)
           (* (((partial 1) F) t x)
              v)))))
#+end_src

Here's a literal function we can play with.

#+begin_src scheme
(define F*
  (literal-function 'F (-> (X Real Real) Real)))
#+end_src

Okay, boom, this is the literal function.

#+begin_src scheme
(define q-prime
  (literal-function 'q-prime))
#+end_src

This is the manual generation of q from q-prime.

#+begin_src scheme
(define ((to-q F) qp)
  (lambda (t) (F t (qp t))))
#+end_src

We can check that these are now equal. This uses C to get us to q

#+begin_src scheme
((compose (F->C F*) (Gamma q-prime)) 't)
#+end_src

And this does it by passing in q manually.

#+begin_src scheme
((Gamma ((to-q F*) q-prime)) 't)
#+end_src

I can convert the proof to code, no problem, by showing that these sides are equal.

YES!! the final step of my proof was the note that these are equal. THIS IS
HUGE!!!

#+begin_src scheme
((compose (lambda (x) (ref x 1)) ((partial 1) (F->C F*)) (Gamma q-prime)) 't)
((compose (lambda (x) (ref x 2)) ((partial 2) (F->C F*)) (Gamma q-prime)) 't)
#+end_src

Just for fun, note that this successfully pushes things inside gamma.

#+begin_src scheme
(let ((L (literal-function 'L (-> (UP Real Real Real) Real)))
      (C (F->C F*)))
  ((Gamma ((to-q ((partial 1) F*)) q-prime)) 't))

(define (p->r t polar-tuple)
  (let* ((r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))

(literal-function 'q-prime (-> Real (UP Real Real)))((Gamma ((to-q p->r) )) 't)
#+end_src


trying again. get a function:

#+begin_src scheme
(define q
  ;; time to x y.
  (literal-function 'q (-> Real (UP Real Real))))

(define (C local)
  (up (time local)
     (square (coordinate local))
     (velocity local)))

((compose C (Gamma q)) 't)
#+end_src

That's good for now.

** Exercise 1.16: Central force motion
:PROPERTIES:
:header-args+: :tangle ch1/ex1-16.scm :comments org
:END:

Messing around to make sure I understand what I'm seeing in the coordinate
transforms on page 45.

#+begin_src scheme
(load "ch1/utils.scm")

(define (p->r local)
  (let* ((polar-tuple (coordinate local))
         (r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))

(define (spherical->rect local)
  (let* ((spherical-tuple (coordinate local))
         (r (ref spherical-tuple 0))
         (theta (ref spherical-tuple 1))
         (phi (ref spherical-tuple 2)))
    (up (* r (sin theta) (cos phi))
        (* r (sin theta) (sin phi))
        (* r (cos theta)))))
#+end_src

Check polar:

#+begin_src scheme
(show-expression
 ((F->C p->r)
  (up 't
      (up 'r 'phi)
      (up 'rdot 'phidot))))
#+end_src

spherical coordinate change, check velocities:

#+begin_src scheme
(show-expression
 ((F->C spherical->rect)
  (up 't
      (up 'r 'theta 'phi)
      (up 'rdot 'thetadot 'phidot))))

(show-expression
 (square (ref (ref ((F->C spherical->rect)
             (up 't
                 (up 'r 'theta 'phi)
                 (up 'rdot 'thetadot 'phidot))) 2) 0)))
#+end_src

get the Langrangian from page 41:

#+begin_src scheme
(define ((L-central-rectangular m U) local)
  (let ((q (coordinate local))
        (v (velocity local)))
    (- (* 1/2 m (square v))
       (U (sqrt (square q))))))
#+end_src

BOOM, now we can compose these things!

#+begin_src scheme
(define (L-central-polar m U)
  (compose (L-central-rectangular m U)
           (F->C p->r)))

(define (L-central-spherical m U)
  (compose (L-central-rectangular m U)
           (F->C spherical->rect)))
#+end_src

Confirm the polar coordinate version...

#+begin_src scheme
(show-expression
 ((L-central-polar 'm (literal-function 'U))
  (up 't
      (up 'r 'phi)
      (up 'rdot 'phidot))))
#+end_src

BOOM, much better than calculating by hand!

#+begin_src scheme
(show-expression
 ((L-central-spherical 'm (literal-function 'U))
  (up 't
      (up 'r 'theta 'phi)
      (up 'rdot 'thetadot 'phidot))))
#+end_src


rectangular, for fun:

#+begin_src scheme
(show-expression
 ((L-central-rectangular 'm (literal-function 'U))
  (up 't
      (up 'x 'y 'z)
      (up 'xdot 'ydot 'zdot))))
#+end_src

From a note to Vinay. Langrangian coordinate transformation from spherical ->
rectangular on paper, which of course is a total nightmare, writing vx^2 +
vy^2 + vz^2 and simplifying. BUT then, of course, you write down the spherical
=> rectangular position change...

the explicit link to function composition, and how the new lagrangian is
(Lagrangian A + A<-B + B<-C)... really drives home how invertible coordinate
transforms can stack associatively through function composition. the lesson is,
prove that the code works, then trust the program to go to crazy coordinate
systems.

they add in a very simple-to-write coordinate transform that has one of the
angles depend on t. and then compose that in, and boom, basically for free
you're in rotating spherical coords.

** Exercise 1.17: Bead on a helical wire

** Exercise 1.18: Bead on a triaxial surface

** Exercise 1.19: Two-bar linkage

** Exercise 1.20: Sliding pendulum


** Exercise 1.21: A dumbbell
:PROPERTIES:
:header-args+: :tangle ch1/ex1-21.scm :comments org
:END:

The uneven dumbbell.

NOTE for when I write this up. This exercise is quite careful to NOT change the
dimension of the configuration space, when it does coordinate transformations.
We show later that you can do that, but that's the reason, good to note, why you
introduce a new variable $c$ that's equal to the distance between the dumbbells.

#+begin_src scheme
(load "ch1/utils.scm")
#+end_src

Takes in any number of up tuples and zips them into a new list of up-tuples by
taking each element.

#+begin_src scheme
(define (up-zip . ups)
  (apply vector-map up (map up->vector ups)))
#+end_src

I spent some time trying to make a nice API... but without map, filter,
reduce etc on tuples it is quite annoying. So let's go ad hoc first and see
what happens.

#+begin_src scheme
(define (KE-particle m v)
  (* 1/2 m (square v)))
#+end_src

#+begin_src scheme
;; gets the particle itself
(define ((extract-particle pieces) local i)
  (let* ((q (coordinate local))
         (qdot (velocity local))
         (indices (apply up (iota pieces (* i pieces))))
         (extract (lambda (tuple)
                    (vector-map (lambda (i) (ref tuple i))
                                indices))))
    (up (time q)
        (extract q)
        (extract qdot))))

(define (constraint q0 q1 F l)
  (* (/ F (* 2 l))
     (- (square (- q1 q0))
        (square l))))

(define ((L-free-constrained m0 m1 l) local)
  (let* ((extract (extract-particle 2))
         (p0 (extract local 0))
         (q_0 (coordinate p0))
         (qdot_0 (velocity p0))

         (p1 (extract local 1))
         (q_1 (coordinate p1))
         (qdot_1 (velocity p1))

         (F (ref (coordinate local) 4)))
    (- (+ (KE-particle m0 qdot_0)
          (KE-particle m1 qdot_1))
       (constraint q_0 q_1 F l))))

(define q-rect
  (up (literal-function 'x_0)
      (literal-function 'y_0)
      (literal-function 'x_1)
      (literal-function 'y_1)
      (literal-function 'F)))
#+end_src

This shows the lagrangian itself, which answers part b:

#+begin_src scheme
(let* ((L (L-free-constrained 'm_0 'm_1 'l))
       (f (compose L (Gamma q-rect))))
  (se (f 't)))
#+end_src

Here are the lagrange equations, confirming part b.

#+begin_src scheme
(let* ((L (L-free-constrained 'm_0 'm_1 'l))
       (f ((Lagrange-equations L) q-rect)))
  (se (f 't)))
#+end_src

Part c - make a change of coordinates.

#+begin_src scheme
(define ((cm-theta->rect m0 m1) local)
  (let* ((q (coordinate local))
         (x_cm (ref q 0))
         (y_cm (ref q 1))
         (theta (ref q 2))
         (c (ref q 3))
         (F (ref q 4))
         (total-mass (+ m0 m1))
         (m0-distance (* c (/ m1 total-mass)))
         (m1-distance (* c (/ m0 total-mass))))
    (up (- x_cm (* m0-distance (cos theta)))
        (- y_cm (* m0-distance (sin theta)))
        (+ x_cm (* m1-distance (cos theta)))
        (+ y_cm (* m1-distance (sin theta)))
        F)))

(se
 ((F->C (cm-theta->rect 'm_0 'm_1))
  (up 't
      (up 'x_cm 'y_cm 'theta 'c 'F)
      (up 'xdot_cm 'ydot_cm 'thetadot 'cdot 'Fdot))))

(define (L-free-constrained-new m0 m1 l)
  (compose (L-free-constrained m0 m1 l)
           (F->C (cm-theta->rect m0 m1))))
#+end_src

This shows the lagrangian itself, after the coordinate transformation:

#+begin_src scheme
(let* ((q (up (literal-function 'x_cm)
              (literal-function 'y_cm)
              (literal-function 'theta)
              (literal-function 'c)
              (literal-function 'F)))
       (L (L-free-constrained-new 'm_0 'm_1 'l))
       (f (compose L (Gamma q))))
  (se (f 't)))
#+end_src

Here are the lagrange equations for part c.

#+begin_src scheme
(let* ((q (up (literal-function 'x_cm)
              (literal-function 'y_cm)
              (literal-function 'theta)
              (literal-function 'c)
              (literal-function 'F)))
       (L (L-free-constrained-new 'm_0 'm_1 'l))
       (f ((Lagrange-equations L) q)))
  (se (f 't)))
#+end_src

For part d, we can substitute the constant value of c to get simplified
equations.

#+begin_src scheme
(let* ((q (up (literal-function 'x_cm)
              (literal-function 'y_cm)
              (literal-function 'theta)
              (lambda (t) 'l)
              (literal-function 'F)))
       (L (L-free-constrained-new 'm_0 'm_1 'l))
       (f ((Lagrange-equations L) q)))
  (se (f 't)))
#+end_src

For part e, I wrote this in the notebook - it is effectively identical to the
substitution that is happening on the computer, so I'm going to ignore this. You
just get more cancellations.


** Exercise 1.22: Driven pendulum

** Exercise 1.23: Fill in the details

** Exercise 1.24: Constraint forces

** Exercise 1.25: Foucalt pendulum Lagrangian

** Exercise 1.26: Properties of $D_t$

** Exercise 1.27: Lagrange equations for total time derivatives

** Exercise 1.28: Total Time Derivatives
:PROPERTIES:
:header-args+: :tangle ch1/ex1-28.scm :comments org
:END:

#+begin_src scheme
(load "ch1/utils.scm")
#+end_src

*** part A

nice, easy to guess.

#+begin_src scheme
(define ((FA m) local)
  (let ((x (coordinate local)))
    (* m x)))
#+end_src

Show the function of t, and confirm that both methods are equivalent.

#+begin_src scheme
(check-f (FA 'm)
         (literal-function 'x))
#+end_src

*** Part B

NOT a total time derivative.

Define G directly:

#+begin_src scheme
(define ((GB m) local)
  (let* ((t (time local))
         (v_x (velocity local))
         (GB0 0)
         (GB1 (* m (cos t))))
    (+ GB0 (* GB1 v_x))))
#+end_src

And show the full G, for fun:

#+begin_src scheme
(let ((f (compose (GB 'm) (Gamma (literal-function 'x)))))
  (se (f 't)))
#+end_src


It's easier to confirm that this is not a total time derivative by checking the
partials.

#+begin_src scheme
(define (GB-properties m)
  (let ((GB0 (lambda (local) 0))
        (GB1 (lambda (local)
               (* m (cos (time local))))))
    (G-properties GB0 GB1 (literal-function 'x))))
#+end_src

It's clear here that the second and third tuple entries aren't equal, so we
don't have a total time derivative.

#+begin_src scheme
(se (GB-properties 'm))
#+end_src

*** Part C

no problem, we've got a total time derivative on our hands.

#+begin_src scheme
(define (FC local)
  (let ((t (time local))
        (x (coordinate local)))
    (* x (cos t))))

(check-f FC (literal-function 'x))

(define GC-properties
  (let ((GC0 (lambda (local)
               (* -1
                  (coordinate local)
                  (sin (time local)))))
        (GC1 (lambda (local)
               (cos (time local)))))
    (G-properties GC0 GC1 (literal-function 'x))))
#+end_src

Boom, the second and third entries are equal, as we'd expect.

#+begin_src scheme
(se GC-properties)
#+end_src


*** Part D

This is NOT a total time derivative; you can tell by taking the partials
of each side, G0 and G1, as we'll see here.

#+begin_src scheme
(define GD-properties
  (let ((GD0 (lambda (local)
               (* (coordinate local)
                  (sin (time local)))))
        (GD1 (lambda (local)
               (cos (time local)))))
    (G-properties GD0 GD1 (literal-function 'x))))
#+end_src

The partials for each side don't match.

#+begin_src scheme
(se GD-properties)
#+end_src

*** Part E

This is strange to me, because I thought that this thing had to produce a tuple.

OH, but the secret is that Qdot is also a tuple, so you contract them together.

Here's the function F that we can use to derive it:

#+begin_src scheme
(define (FE local)
  (let* ((t (time local))
         (q (coordinate local))
         (x (ref q 0))
         (y (ref q 1)))
    (* (+ (square x) (square y))
       (cos t))))
#+end_src

Boom, total time derivative!

#+begin_src scheme
(check-f FE (up (literal-function 'x)
                (literal-function 'y)))
#+end_src

And let's show that we pass the tests by decomposing this into G0 and G1:

#+begin_src scheme
(define GE-properties
  (let (
        ;; any piece of the function without a velocity multiplied.
        (GE0 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (* -1
                    (+ (square x) (square y))
                    (sin t)))))

        ;; The pieces multiplied by velocities, split into a down tuple of
        ;; components, one for each of the coordinate components.
        (GE1 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (down
                  (* 2 x (cos t))
                  (* 2 y (cos t)))))))
    (G-properties GE0 GE1 (up (literal-function 'x)
                              (literal-function 'y)))))
#+end_src

BOOM!

We've recovered F; the partials are equal, and the final matrix is symmetric.

#+begin_src scheme
(se GE-properties)
#+end_src

*** Part F

This one is interesting, since the second partial is a tuple. This is not so
obvious to me, so first let's check the properties:

#+begin_src scheme
(define GF-properties
  (let (
        ;; any piece of the function without a velocity multiplied.
        (GF0 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (* -1
                    (+ (square x) (square y))
                    (sin t)))))

        ;; The pieces multiplied by velocities, split into a down tuple of
        ;; components, one for each of the coordinate components.
        (GF1 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (down
                  (+ (cube y) (* 2 x (cos t)))
                  (+ x (* 2 y (cos t))))))))
    (G-properties GF0 GF1 (up (literal-function 'x)
                              (literal-function 'y)))))
#+end_src

AND it looks like we DO have a total time derivative, maybe. We certainly pass
the first test here, since the second and third tuple entries are equal.

BUT we fail the second test; the hessian that we get from ((partial 1) G1) is
not symmetric.

#+begin_src scheme
(se GF-properties)
#+end_src


** Exercise 1.29: Galilean Invariance
:PROPERTIES:
:header-args+: :tangle ch1/ex1-29.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

I'll do this for a single particle, since it's annoying to get the sum going
for many; and the lagrangian is additive, so no problem.

#+begin_src scheme
(define (uniform-translate-shift->rect local)
  (let* ((t (time local))
         (q (coordinate local))
         (xprime (ref q 0))
         (delta_x (ref q 1))
         (delta_v (ref q 2)))
    (+ xprime delta_x (* t delta_v))))

(define (L-translate-shift m)
  (compose (L-free-particle m)
           (F->C uniform-translate-shift->rect)))
#+end_src

#+RESULTS:
: #| uniform-translate-shift->rect |#
:
: #| L-translate-shift |#

First, confirm that if we have a constant, we get what we expected from paper.

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (up (literal-function 'xprime)
              (lambda (t) 'Delta_x)
              (lambda (t) 'Delta_v)))
       (f (compose (L-translate-shift 'm) (Gamma q))))
  (->tex-equation (f 't)))
#+end_src

#+RESULTS[5d2b4de08cfab4779bf7cdab31d518191b40a4d2]:
\[\begin{equation}
{{1}\over {2}} {{\Delta}_{v}}^{2} m + {\Delta}_{v} m D{x}^\prime\left( t \right) + {{1}\over {2}} m {\left( D{x}^\prime\left( t \right) \right)}^{2}
\end{equation}\]

We can change this a little to see the extra terms; substract off the free
particle lagrangian, to see the extra stuff.

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (up (literal-function 'xprime)
              (lambda (t) 'Delta_x)
              (lambda (t) 'Delta_v)))
       (L (- (L-translate-shift 'm)
             (L-free-particle 'm)))
       (f (compose L (Gamma q))))
  (->tex-equation (f 't)))
#+end_src

#+RESULTS[c17004e61fec7edb3835203cdc99c562940bee7c]:
\[\begin{equation}
{{1}\over {2}} {{\Delta}_{v}}^{2} m + {\Delta}_{v} m D{x}^\prime\left( t \right)
\end{equation}\]

Here's the gnarly version with both entries as actual functions. Can this be a
total time derivative? It CANNOT be, because we have a $(D \Delta_v(t))^2$ term
in there, and we know that total time derivatives have to be linear in the
velocities. The function $F$ would have had to have a velocity in it, which is
not allowed.

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (up (literal-function 'xprime)
              (literal-function 'Delta_x)
              (literal-function 'Delta_v)))
       (L (- (L-translate-shift 'm)
             (L-free-particle 'm)))
       (f (compose L (Gamma q))))
  (->tex-equation (f 't)))
#+end_src

#+RESULTS[ded4f6dec25954c9b7536153e1db8db0315cb399]:
\[ \begin{equation}
{{1}\over {2}} m {t}^{2} {\left( D{\Delta}_{v}\left( t \right) \right)}^{2} + m t D{x}^\prime\left( t \right) D{\Delta}_{v}\left( t \right) + m t D{\Delta}_{v}\left( t \right) {\Delta}_{v}\left( t \right) + m t D{\Delta}_{v}\left( t \right) D{\Delta}_{x}\left( t \right) + m D{x}^\prime\left( t \right) {\Delta}_{v}\left( t \right) + m D{x}^\prime\left( t \right) D{\Delta}_{x}\left( t \right) - {{1}\over {2}} m {\left( D{\Delta}_{v}\left( t \right) \right)}^{2} + {{1}\over {2}} m {\left( {\Delta}_{v}\left( t \right) \right)}^{2} + m {\Delta}_{v}\left( t \right) D{\Delta}_{x}\left( t \right)
\end{equation} \]

Let's simplify by making the $\Delta_v$ constant and see if there's anything so
obvious about $\Delta_x$.

We know that we have a total derivative when $\Delta_x$ is constant, and we know
that total time derivatives are linear, so let's substract off the total time
derivative and see what happens:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (lambda (dx)
            (up (literal-function 'xprime)
                dx
                (lambda (t) 'Delta_v))))
       (L (- (L-translate-shift 'm)
             (L-free-particle 'm)))
       (f (lambda (dx)
            (compose L (Gamma (q dx))))))
  (->tex-equation
   ((- (f (literal-function 'Delta_x))
       (f (lambda (t) 'Delta_x)))
    't)))
#+end_src

#+RESULTS[1a9463beb2f26c1661f1978633ca830ba12f73ec]:
\[\begin{equation}
{\Delta}_{v} m D{\Delta}_{x}\left( t \right) + m D{x}^\prime\left( t \right) D{\Delta}_{x}\left( t \right)
\end{equation}\]

Take a look. there is a quadratic velocity term in here! We have $D \Delta_x(t)
D x'(t)$. This is not allowed in a total time derivative.

SO, only if the shift and uniform translation are constant do we not affect the
Lagrangian value.

** Exercise 1.30: Orbits in a central potential
** Exercise 1.31: Foucault pendulum evolution
** Exercise 1.32: Time-dependent constraints
** Exercise 1.33: Falling off a log
** Exercise 1.34: Driven spherical pendulum
** Exercise 1.35: Restricted equations of motion
** Exercise 1.36: Noether integral
** Exercise 1.37: Velocity transformation
** Exercise 1.38: Properties of $E$
** Exercise 1.39: Combining Lagrangians
** Exercise 1.40: Bead on a triaxial surface
** Exercise 1.41: Motion of a tiny golf ball
** Exercise 1.42: Augmented Lagrangian
** Exercise 1.43: A numerical investigation
** Exercise 1.44: Double pendulum behavior

* Rigid Bodies

** Exercise 2.1
** Exercise 2.2
** Exercise 2.3
** Exercise 2.4
** Exercise 2.5
** Exercise 2.6
** Exercise 2.7
** Exercise 2.8
** Exercise 2.9
** Exercise 2.10
** Exercise 2.11
** Exercise 2.12
** Exercise 2.13
** Exercise 2.14
** Exercise 2.15
** Exercise 2.16
** Exercise 2.17
** Exercise 2.18
** Exercise 2.19
** Exercise 2.20

* Hamiltonian Mechanics

** Exercise 3.1
** Exercise 3.2
** Exercise 3.3
** Exercise 3.4
** Exercise 3.5
** Exercise 3.6
** Exercise 3.7
** Exercise 3.8
** Exercise 3.9
** Exercise 3.10
** Exercise 3.11
** Exercise 3.12
** Exercise 3.13
** Exercise 3.14
** Exercise 3.15
** Exercise 3.16

* Phase Space Structure

** Exercise 4.0
** Exercise 4.1
** Exercise 4.2
** Exercise 4.3
** Exercise 4.4
** Exercise 4.5
** Exercise 4.6
** Exercise 4.7
** Exercise 4.8
** Exercise 4.9
** Exercise 4.10

* Canonical Transformations

** Exercise 5.1
** Exercise 5.2
** Exercise 5.3
** Exercise 5.4
** Exercise 5.5
** Exercise 5.6
** Exercise 5.7
** Exercise 5.8
** Exercise 5.9
** Exercise 5.10
** Exercise 5.11
** Exercise 5.12
** Exercise 5.13
** Exercise 5.14
** Exercise 5.15
** Exercise 5.16
** Exercise 5.17
** Exercise 5.18
** Exercise 5.19
** Exercise 5.20

* Canonical Evolution

** Exercise 6.1
** Exercise 6.2
** Exercise 6.3
** Exercise 6.4
** Exercise 6.5
** Exercise 6.6
** Exercise 6.7
** Exercise 6.8
** Exercise 6.9
** Exercise 6.10
** Exercise 6.11
** Exercise 6.12

* Canonical Perturbation Theory

** Exercise 7.1
** Exercise 7.2
** Exercise 7.3
** Exercise 7.4
** Exercise 7.5

* Our Notation
  :PROPERTIES:
  :header-args: :eval never-export
  :END:

Notation Appendix. This is all about getting cozy with scheme, and with the
various idiosyncracies of the tuple and functional notation.

** Exercise 9.1 Chain Rule
     :PROPERTIES:
     :header-args+: :tangle ch9/ex9-1.scm :comments org
     :END:

You're supposed to do these by hand, so I'll do that in the textbook. But here,
let's redo them on the machine.

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

***** Compute $\partial_0 F(x, y)$ and $\partial_1 F(x, y)$

First, let's define the functions we need.

#+begin_src scheme
(define (F x y)
  (* (square x)
     (cube y)))

(define (G x y)
  (up (F x y) y))

(define (H x y)
  (F (F x y) y))
#+end_src

#+RESULTS:
: #| F |#
:
: #| G |#
:
: #| H |#

 You can do this with explicit partials:

#+begin_src scheme :results value raw :exports both :cache yes
(let ((f (down ((partial 0) F) ((partial 1) F))))
  (->tex-equation
   (f 'x 'y)))
#+end_src

#+RESULTS[b8eaf52d98e5903b52306509dcdc8f8eeb97144c]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 3 {x}^{2} {y}^{2}}\end{bmatrix}
\end{equation}

Or with the $D$ symbol:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((D F) 'x 'y))
#+end_src

#+RESULTS[f3fba605ac97a3ebd30b4a96aca31eed921e2e93]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 3 {x}^{2} {y}^{2}}\end{bmatrix}
\end{equation}

Or, we could show that they're equivalent this way:

#+begin_src scheme :results value raw :exports both :cache yes
(let ((f (down ((partial 0) F) ((partial 1) F))))
  (->tex-equation
   (- ((D F) 'x 'y)
      (f 'x 'y))))
#+end_src

#+RESULTS[bbfc31a98ddca1b434403a34cefb730e354f1be8]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 0} \cr \cr \displaystyle{ 0}\end{bmatrix}
\end{equation}

***** Compute $\partial_0 F(F(x, y), y)$ and $\partial_1 F(F(x, y), y)$

$H$ is already that composition, so:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((D H) 'x 'y))
#+end_src

#+RESULTS[22a0dfcbcf713d36b0f899b6baac6dbf1ec4b56d]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 4 {x}^{3} {y}^{9}} \cr \cr \displaystyle{ 9 {x}^{4} {y}^{8}}\end{bmatrix}
\end{equation}

***** Compute $\partial_0 G(x, y)$ and $\partial_1 G(x, y)$

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((D G) 'x 'y))
#+end_src

#+RESULTS[548f447f81ffe817f686965fb5fdc1d0cbecc5f9]:
\begin{equation}
\begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 3 {x}^{2} {y}^{2}} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}
\end{equation}

***** Compute $DF(a, b)$, $DG(3, 5)$ and $DH(3a^2, 5b^3)$

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 (up ((D F) 'a 'b)
     ((D G) 3 5)
     ((D H) (* 3 (square 'a)) (* 5 (cube 'b)))))
#+end_src

#+RESULTS[e0ef4bfc15551f9d05baeb3970cd8dafaf02db65]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ 2 a {b}^{3}} \cr \cr \displaystyle{ 3 {a}^{2} {b}^{2}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 750} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 675} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ 210937500 {a}^{6} {b}^{27}} \cr \cr \displaystyle{ 284765625 {a}^{8} {b}^{24}}\end{bmatrix}}\end{pmatrix}
\end{equation}

** Exercise 9.2: Computing Derivatives
     :PROPERTIES:
     :header-args+: :tangle ch9/ex9-2.scm :comments org
     :END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

A further exercise is to try defining the functions so that they use explicit
tuples, so you can compose them:

#+begin_src scheme
(define (F* v)
  (let ((x (ref v 0))
        (y (ref v 1)))
    (* (square x) (cube y))))

(define (G* v)
  (let ((x (ref v 0))
        (y (ref v 1)))
    (up (F* v) y)))

(define H* (compose F* G*))
#+end_src

#+RESULTS:
: #| F* |#
:
: #| G* |#
:
: #| H* |#

to be really pro, I'd make a function that takes these as arguments and prints a
nice formatted exercise output. Let's do the final exercise, for fun:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 (up ((D F*) (up 'a 'b))
     ((D G*) (up 3 5))
     ((D H*) (up (* 3 (square 'a)) (* 5 (cube 'b))))))
#+end_src

#+RESULTS[1e43354828c8ce0ba497bcc6bd9e64c4f4e20419]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ 2 a {b}^{3}} \cr \cr \displaystyle{ 3 {a}^{2} {b}^{2}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 750} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 675} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ 210937500 {a}^{6} {b}^{27}} \cr \cr \displaystyle{ 284765625 {a}^{8} {b}^{24}}\end{bmatrix}}\end{pmatrix}
\end{equation}

* Org-Mode Demo
  :PROPERTIES:
  :header-args: :eval no-export
  :END:

This is an example of how we might structure an org-mode file that can export
out to Github flavored Markdown, or to a PDF.

First, let's get some code loaded up and written. Here's a block that converts
polar coordinates to rectangular coordinates.

#+name: p->r
#+begin_src scheme :eval no
(define (p->r local)
  (let* ((polar-tuple (coordinate local))
         (r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))
#+end_src

This is some good stuff.

#+begin_src scheme :results output :noweb yes :comments both
(load "ch1/utils.scm")

<<p->r>>

<<spherical->rect>>
#+end_src

And another, that gets us from spherical to rectangular.

#+name: spherical->rect
#+begin_src scheme :eval no
(define (spherical->rect local)
  (let* ((spherical-tuple (coordinate local))
         (r (ref spherical-tuple 0))
         (theta (ref spherical-tuple 1))
         (phi (ref spherical-tuple 2)))
    (up (* r (sin theta) (cos phi))
        (* r (sin theta) (sin phi))
        (* r (cos theta)))))
#+end_src

#+RESULTS[f4f039075baf66ba4fe071844815bfcffe281eaa]:
: ;Loading "ch1/utils.scm"... done
: #| "" |#

This block will generate a LaTeX version of the code I've supplied:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((+ (literal-function 'c)
     (D (literal-function 'z)))
  't)
 "eq:masterpiece")
#+end_src

#+RESULTS[b383d2f5d6c252ac04a5f44aaeaec678132b8449]:
\begin{equation}
c\left( t \right) + Dz\left( t \right)
\label{eq:masterpiece}
\end{equation}

You can even reference these with equation numbers, like Equation \eqref{eq:masterpiece} above.

#+begin_src scheme :results value :exports both :cache yes
(up 1 2 't)
#+end_src

#+RESULTS:
: #|
: (up 1 2 t)
: |#

*** Equations

Here's (a test) of $a = bc$ and more $$ \alpha_t $$ equations:

And again this is a thing:

\[
e^{i\pi} = -1
\]

\[
\int_0^\infty e^{-x^2} dx = \frac{\sqrt{\pi}}{2}
\]


$\vec{x} \dot (\vec{x} \times \vec{v}) = \vec{v} \dot (\vec{x} \times \vec{v}) =
0$

$\vec{x} \cdot (\vec{x} \times \vec{v}) = \vec{v} \dot (\vec{x} \times \vec{b}) =
0$
